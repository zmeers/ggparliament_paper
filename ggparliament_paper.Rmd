---
title: "`ggparliament`:" 
subtitle: "Simple Parliament Plots in `R`"
author: "Zoe Meers ^[United States Studies Center, University of Sydney]"
date: "Draft as of `r format(Sys.time(), '%B %d, %Y')`"
output: 
  pdf_document:
  latex_engine: xelatex
  df_print: kable
header-includes:
- \usepackage{booktabs}
- \usepackage{setspace}\doublespacing
fontsize: 12pt
citecolor: pink
bibliography: ggparliament.bib
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      warning = FALSE, 
                      message = FALSE, 
                      dpi=300,
                      fig.width = 4, 
                      fig.height = 4,
                      cache = FALSE,
                      fig.align = "center",
                      fig.pos = 'H',
                      knitr.table.format = "latex")
library(tidyverse)
library(ggparliament)
library(ussc)
library(patchwork)
library(knitr)
library(png)
library(grid)
```
\newpage

# Introduction

In this article, I introduce a new data visualization tool in `R` for graphing legislatures. This `R` package, `ggparliament`, allows for easy visualization of legislatures, including district-level descriptive data, election results; in addition, it can be used to analyse the structure and design of political institutions [@ggparliament].  Graphing legislatures and parliaments provide information that may be easy to miss in tabular form but nearly impossible to miss visually. `ggparliament` is a `ggplot2` [@R-ggplot2] extension that takes aggregate election returns, expands the rows of the data frame to the number of individual seats in the legislature, and plots the parliament according to a specified parliament layout. Such graphs are known as parliament plots. 

Visualizing legislatures can be challenging. Users must find the x and y coordinates for each individual seat, and plot the points on a coordinate plane. While this task is not impossible, parliament plots are cubersome to create in most statistical software packages. Until relatively recently, parliament plots were plotted using various JavaScript frameworks. Programs such as 'd3-parliament' [@d3-parliament], 'Parliament SVG' [@parliament-svg] and 'Westminster SVG' [@westminster-svg] give the end-user greater freedom to draw directly on the Document Object Model^[In common parlance, an empty webpage.] using Scalable Vector Graphics (SVG). Click-and-point options also exist for non-programmers, including 'Parliament Diagram' [@parliamentdiagram] which is primarily used for writing Wikipedia articles. These tools, while excellent, are not particularly appropriate or useful choices for political scientists.^['D3.js' and other 'JavaScript' frameworks are more often used by front end web developers, not academics. Likewise, Wikipedia charts do not fit well with the workflow of the modal political scientist.] `ggparliament` seamlessly integrates into the quantitative political scientist's toolkit and allows for easy composition of legislatures using `ggplot2` syntax in the `tidyverse` [@R-tidyverse], a set of packages driven by an opinionated data science philosophy in `R`.

To highlight the utility of `ggparliament` in political science, I first situate this `R` package in the context of other data visualization tools used in the discipline. I then show how to visualize parliament plots. Finally, I expand on several cases in which `ggparliament` may improve comprehension of descriptive data in political science.  

# Literature review

Data visualization in political science is not new. Several scholars have encouraged use of graphs vis-Ã -vis tables in communicating scientific research [@king2000making; @tomz2003clarify]. Kastellec and Leoni follow up on this effort several years later, proposing ways to graph statistical results in political science that would otherwise be presented as a table [@KastellecLeoni]. Others have written fairly extensively on graphics and presenting information in political science and in statistics [@gelman2011tables]. Visualizing data has increased in popularity in the social sciences as computational tools become more accessible. Political scientists, like Edward Tufte, are prolific data visualizers, having transformed how political scientists visualize information [@tufte1983visual].

Yet, while statistical research computing in political science has increased in use since the 1970s [see @SPSS, @Stata, @Stan, @pscl, @quanteda, @amelia, @stm for examples of statistical computing languages or developments made for and by social scientists.], data visualization tools still remain the domain expertise of people in computational statistics and/or Human Computer Interaction. Specialist data visualization tools in political science are rare. However, there are a few noteable data visualization achievements that originate from political science, including small multiples [@tufte1990envisioning], marginal effects plots [@brambor2006understanding; @hainmueller2018much; @pepinsky2018visual] and the separation plot [@greenhill2011separation].

# Data visualization in political science 

An analysis of journal articles from the *American Journal of Political Science*, *American Political Science Review*,  *Journal of Politics*, and *Political Analysis* published in 2018 show that the inclusion of figures and graphs are common-place in political science.

```{r, fig.height = 4, fig.width= 8, fig.cap="Political science and data visualization", fig.pos = "h"}
graph_style <- data.frame(
  year = c(2018),
  journal = c("AJPS", "JOP", "APSR", "PA"),
  ggplot2 = c(16, 10, 4, 3),
  other = c(21, 44, 25, 8),
  none = c(7, 18, 14, 3)
)
graph_style_long <- graph_style %>% 
  gather(-journal, -year, ggplot2, other, none) %>% 
  rename('type' = '-journal', 'count' = '-year')


a <- ggplot() + 
  geom_bar(data=graph_style_long, aes(x = journal, 
                                      y = count, 
                                      fill = type),
           stat = "identity",
           position = "dodge",
           alpha = 0.9) +
  theme_minimal() + 
  scale_fill_viridis_d() + 
  labs(title='Data visualization styles in\nselect political science journals',
       subtitle = 'Analysis of articles published in 2018 only.',
       x='', y='Count',
       fill = NULL)  + 
  theme(plot.title = element_text(face = "bold"),
        axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=7))
#ggsave(last_plot(), file = "figure1_datavis.png")
graph_style_prop <- graph_style %>% 
  dplyr::select(ggplot2, other, none)
graph_style_prop <- round(graph_style_prop/rowSums(graph_style_prop), 2)*100
graph_style_prop$year <- 2018
graph_style_prop$journal <- c("AJPS", "JOP", "APSR", "PA")
graph_style_prop <- graph_style_prop[c(5,4,1,2,3)]
graph_style_prop_long <- graph_style_prop %>% 
  gather(-journal, -year, ggplot2, other, none)%>% 
  rename('journal'='journal' , 'year' = '-year', 'type' = '-journal', 'prop' = '-year')

b <- ggplot(graph_style_prop_long,
       aes(journal,
           prop, 
           fill=type,
           group=round(prop))) + 
  geom_bar(stat="identity",
           alpha = 0.9) +
  theme_void() + 
  scale_fill_viridis_d() + 
  labs(title='Relative percentage of data\nvisualization styles',
       caption = 'Note: the "other" category consists of multiple data visualization libraries including base R, Lattice, and Stata.',
       x='', y='',
       fill = NULL) + 
  theme(legend.position = 'none', 
        legend.title = element_blank(),
        axis.ticks = element_blank(),
        panel.grid = element_blank(), 
        panel.border = element_blank(),
        plot.title = element_text(face = "bold"),
        axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10)) +
  coord_flip()  


#ggsave(last_plot(), file="figure2_datavis.png")

a + b
#ggsave(journal_analysis, file="figures/journalanalysis_datavis.png",width = 8, height = 4)
```


While nearly half of the articles in the four journals do not contain graphs, this is an unsurprising result given that there are subfields or areas of research within subdisciplines in political science in which there is little need to graph results. Of the articles that do contain data visualizations, a significant proportion are made in `ggplot2`. In the *American Journal of Political Science*, 36% of articles published in 2018 include `ggplot2` graphics. 

While `ggplot2` is just one data visualization tool out of many, this analysis provides evidence of the popularity of the `tidyverse` packages in political science. The use of data visualization as a means to communicate results is strongly encouraged in political science. The relative accessibility of tools like `ggplot2` enable social scientists to easily communicate their results graphically. 

# Simple Parliament Plots

`ggparliament` is an extension to the `tidyverse`, a subset of packages in `R` which build off a common grammar of graphics and data analysis, enabling users to quickly understand their data through chained functions [@wilkinson2006grammar, @wickham2010layered]. The output can be visualized with ease in `ggplot2`. `ggparliament` is the first data visualization tool in a statistical framework for displaying election returns, party structures, and legislative data in a parliament plot.  `ggparliament` offers five legislative chamber layouts for plotting parliament plots. 
```{r, fig.width=6, fig.height = 3.5, fig.cap="Basic parliament plots", fig.pos = "h"}
# Semicircle
data <- election_data %>% 
  filter(country == "USA" & year == 2016 & 
           house == "Representatives") %>% 
  parliament_data(election_data = ., 
            parl_rows = 8, 
            party_seats = .$seats,
            type = 'semicircle')
semicircle <- ggplot(data, aes(x,y), colour = "black") + 
  geom_parliament_seats(size = 0.5) + 
  theme_ggparliament() + labs(subtitle = "Semicircle")

# Circle
data <- election_data %>% 
  filter(country == "USA" & year == 2016 & 
           house == "Representatives") %>% 
  parliament_data(election_data = ., 
            parl_rows = 7, 
            party_seats = .$seats,
            type = 'circle')
circle <- ggplot(data, aes(x,y), colour = "black") + 
  geom_parliament_seats(size = 0.5) + 
  theme_ggparliament() + labs(subtitle = "Circle")

# Classroom
data <- election_data %>% 
  filter(country == "Russia" & year == 2016 ) %>% 
  parliament_data(election_data = ., 
            parl_rows = 14, 
            party_seats = .$seats,
            type = 'classroom')
classroom <- ggplot(data, aes(x,y), colour = "black") + 
  geom_parliament_seats(size = 0.5) + 
  theme_ggparliament() + labs(subtitle = "Classroom")

# Horseshoe 
data <- election_data %>% 
  filter(country == "Australia" & year == 2016 & 
           house == "Representatives") %>% 
  parliament_data(election_data = ., 
            parl_rows = 4, 
            party_seats = .$seats,
            type = 'horseshoe')
horseshoe <- ggplot(data, aes(x,y), colour = "black") + 
  geom_parliament_seats(size = 0.5) + 
  theme_ggparliament() + labs(subtitle = "Horseshoe")

# Opposing bench
data <- election_data %>% 
  filter(country == "UK" & year == 2017) %>% 
  parliament_data(election_data = ., 
            parl_rows = 14, 
            group = .$government,
            party_seats = .$seats,
            type = 'opposing_benches')
ob <- ggplot(data, aes(x,y), colour = "black") + 
  geom_parliament_seats(size = 0.5)  + 
  theme_ggparliament() + labs(subtitle = "Opposing Benches")

(ob | horseshoe | classroom) / (semicircle | circle | plot_spacer() )
```

Simple descriptive statistics such as election results are often best represented in tables. However, I argue that parliament plots do have some utility. Graphs provide a  accurate summmary of the distribution of seats in a legislature. They can be used to visually group parties together when the number of parties exceeds a two-party system or can make explicitly clear the seat swing between two elections. As `ggparliament` provides several parliament layouts, one can create a cross-country comparative analyis. Moreover, parliament plots allow readers to visualize the layout of the legislature. Moving away from the primary intended purpose of plotting election results, `ggparliament` can display information about legislative districts, roll call data, or information about legislators themselves in a compact format.

# The Concept

Constructing a parliament plot starts with aggregate political data. To illustrate how to use `ggparliament`, I take the 115th Congress as an example. As of August 2018, there are 236 Republicans, 193 Democrats and 6 vacant seats in the House of Representatives which are equally divided by the two political parties. The data frame is structured as follows:

```{r, echo = FALSE}
house_of_reps <- data.frame( 
  party = c("Vacancies","Republicans", "Democrats", "Vacancies"),
  seats = c(3, 236, 193, 3),
  color = c("gray", "red", "blue", "gray")
) %>% mutate(party = as.character(party), color = as.character(color))
knitr::kable(house_of_reps, caption = "The United States House of Representatives")
```

Next, we input the data frame into `ggparliament::parliament_data()`, defining the parameters of interest: 

* the type of parliament layout (hemicycle, circle, horseshoe, classroom, or oppposing benches)

* the number of rows in the legislative chamber 

* the numerical 'seats' variable which tells `R` the total number of seats per party 

* the name of the original aggregate data frame.^[If you are plotting an opposing benches style parliament for the House of Commons, you must add an additional grouping variable to split the two benches.]


```{r, echo = FALSE}
house_of_reps_new <- parliament_data(election_data = house_of_reps,
                            parl_rows = 8,
                            party_seats = house_of_reps$seats,
                            type = 'semicircle')

knitr::kable(head(house_of_reps_new), caption = "`ggparliament::parliament_data()` output")
```

The function `parliament_data()` is primarily dependent on two arguments: the number of rows in the legislative chamber and specified layout. The data frame expands to individual rows for any given legislator with x and y coordinates assigned to their seat. The user can then bind other information to the seat by appending new columns to the data. Plotting the output in `ggparliament` leads to the following graph (see Figure 3).

```{r, fig.width = 3.5, fig.height = 2.5, fig.pos="h", fig.cap="United States House of Representatives parliament plot"}
ggplot(data = house_of_reps_new) +
  geom_parliament_seats(aes(x = x,  y = y, color = party), size = 2) +
  theme_ggparliament() +
  labs(color = NULL) + 
  theme(legend.position = 'bottom') + 
  scale_color_manual(values = house_of_reps_new$color, 
                     limits = house_of_reps_new$party)
```

# Additional Information

The primary purpose of `ggparliament` is to plot election returns. However, there exists a lot of potential for plotting other types of descriptive political data. We can append additional information to parliament plots, including faceting legislatures over time or pieces of legislation, plotting majority threshold lines, or grouping coalition governments together. 

The `tidyverse` facilitates easy matrixing of variables through faceting, which is helpful for analysing change in legislative bodies over time. Note that we can facet the graph by any variable - a good use for `ggparliament` may be plotting roll call votes over a number of legislative sessions - although it is best to facet by a variable in which observations exist for all cases and, in general, faceting temporally makes intuitive sense. In the following example, I plot the House of Commons in the United Kingdom from 2010 to 2017 (see Figure 4). In doing so, it allows us to see the seat swing in the legislature over several election cycles. 

```{r, fig.height = 5, fig.width = 8, fig.cap = "House of Commons small multiples", fig.pos = "h"}
house_of_commons <- election_data %>% 
  filter(country == "UK") %>%
  split(.$year) %>% 
  purrr::map(~parliament_data(election_data = .,
                              parl_rows = 15,
                              group = .$government,
                              type = 'opposing_benches',
                              party_seats = .$seats)) %>% 
  bind_rows()

ggplot(data = house_of_commons, 
       aes(x = x, y = y, color = party_long)) +
  geom_parliament_seats(size = 1.5) +  
  facet_wrap(~year, ncol = 3) +
  scale_color_manual(values = house_of_commons$colour, 
                     limits = house_of_commons$party_long) +
  guides(color = guide_legend(nrow = 3, 
                              title = "Political parties:",
                              title.position = 'top', 
                              title.hjust = 0.5)) +
  theme(legend.position = 'bottom', 
        panel.background = element_rect(colour = 'grey'),
        axis.text = element_blank(),
        axis.title = element_blank(),
        panel.grid = element_blank(),
        axis.ticks = element_blank()) +
  scale_x_reverse()
```


Another key advantage of `ggparliament` versus presenting descriptive data in a table is that users can collapse or add variables to plot, appending an additional visual layer each time. The parliament plot can be helpful when highlighting coalitions as it adds a visual dimension to the data. To show how visually highlighting seats can appeal, I provide the 2016 election results for the Australian House of Representatives in tabular format below as well as a `ggparliament` object.


```{r, results='asis'}
australia <- election_data %>% 
  filter(country == "Australia" &
           year == 2016 &
           house == "Representatives") %>% 
  mutate(party_long = replace(party_long, party_long == "Labour", "Labor")) %>% 
  select(-c("year", "country","house", "party_short", "colour", "government")) %>% 
  rename(party = party_long)
australia_simplified <- australia %>% 
  mutate(party = fct_collapse(party,
  Other = c("Greens","Xenophon Team", "Independent", "Katter's Australian"),
  Coalition = c("Liberal", "Liberal National", "National"),
  Labor = c("Labor"))) %>% 
  mutate(seats = case_when(
    party == "Coalition" ~ 76,
    party == "Other" ~ 5, 
    party == "Labor" ~ 69
  )) %>% 
  distinct()

cat(c("\\begin{table}[!htb]
    \\begin{minipage}{.5\\linewidth}
      \\caption{2016 Australian federal election results}
      \\centering",
        knitr::kable(australia, format = "latex", booktabs = TRUE),
    "\\end{minipage}%
    \\begin{minipage}{.5\\linewidth}
      \\centering
        \\caption{Simplified election results}",
        knitr::kable(australia_simplified, format = "latex", booktabs = TRUE),
    "\\end{minipage} 
\\end{table}"
))  

```

There is nothing *incorrect* about either table. However, a parliament plot highlights members of the coalition in addition to plotting all of the parties that make up the coalition. For the purpose of visually displaying the parties that make up the Australian government compared to the opposition, a *simple* parliament plot provides as much utility as the tables above (i.e. very little -- indeed, a visual drawing of Table 3). However, using visual tools to highlight subsets of the data allow for near-instant comprehension (see Figure 5). We gain the additional information from visually grouping and highlighting the coalition. In doing this, we do not *lose* information about individual parties. 


```{r, fig.width=3.5, fig.height = 3.5, fig.cap = "Highlighting the Coalition government in the Australian House of Representatives", fig.pos = "h"}
australia <- election_data %>% 
  filter(country == "Australia" &
           year == 2016 &
           house == "Representatives") %>% 
  mutate(party_long = replace(party_long, party_long == "Labour", "Labor")) %>% 
  parliament_data(election_data = .,
                  parl_rows = 4,
                  type = 'horseshoe',
                  party_seats = .$seats) 
ggplot(data = australia, aes(x = x, y = y, color = party_long)) +
  geom_parliament_seats(size = 1.5) + 
  geom_highlight_government(government == 1, size = 1.5, colour = "pink") +
  labs(title = "Australian House of Representatives") + 
  geom_curve(aes(x = 7.5, y = 10, xend = 7, yend = 8), 
             colour = 'grey', curvature = -0.2,
             arrow = arrow(length = unit(0.03, "npc"))) +
  annotate("text", x = 7.7, y = 10.2,label = "The Coalition", colour = "pink") + 
  scale_color_manual(values = australia$colour, 
                     limits = australia$party_long) +
  theme_ggparliament() + 
  theme(legend.position = 'bottom') +
  guides(colour = guide_legend(title = "Political Parties:", 
                               title.hjust = 0.5, 
                               nrow = 3,
                               title.position = "top", 
                               keywidth = 0.5))
```



Another quantity of interest is the absolute majority threshold. We can calculate this by halving the total number of seats in the legislature, rounding to the next integer to reach an absolute majority of seats. The formula for this metric is simply:
$$ Absolute\ majority = \lfloor \frac{seats}{2} \rceil $$
Graphically, `ggparliament` draws a line through the majority threshold seat, with an optional annotation noting the number of seats required to claim a majority. 

```{r, fig.width = 3.5, fig.height = 2.5, fig.pos="h", fig.cap="United States House of Representatives with a majority threshold line"}
ggplot(data = house_of_reps_new) +
  geom_parliament_seats(aes(x = x,  y = y, color = party), 
                        size = 2) +
  theme_ggparliament() +
  draw_majoritythreshold(n = round(nrow(house_of_reps_new)/2), 
                         label = FALSE, 
                         type = 'semicircle', 
                         linesize = 0.5) + 
  theme(legend.position = 'bottom') +
  labs(color = NULL) + 
  scale_color_manual(values = house_of_reps_new$color, 
                     limits = house_of_reps_new$party)
```

Drawing the majority threshold may be of interest when the majority margin is slim. However, it also offers additional advantages in explicitly making clear the difference between the number of seats won by the government versus the bare minimum needed to call the election or vote. 

The package also comes with several smaller functions. `ggparliament` provides a function to distinguish overhang seats, where the number of national-level party votes exceeds the number of division-level seats won in MMP electoral systems; the excess is allocated to the party to make up the difference. Additionally, the `R` package includes a function to calculate and plot seat share in the legislative body.


```{r, fig.width = 6, fig.height = 3, fig.pos = 'h', fig.cap="German Bundestag - 2013 election"}
data <- election_data %>%
  filter(country == "Germany" & year == "2013") %>% # on the federal level, CSU is a part of CDU
  mutate(seats = gsub("255", "311", seats)) %>% # Add the 56 CSU seats to CDU
  mutate(seats = as.numeric(as.character(seats))) %>%
  filter_all(all_vars(!grepl('Christian Social Union in Bavaria',.)))
# binary variable for overhang seat
overhangseats <- c(1, 0, 1, 0, 1, 0, 1, 0)
# number of overhang seats and remainder for each party
number_overhangseats <- c(3, 61, 3, 60,16, 295, 11, 182)
# expand data
german_data <- parliament_data(
  election_data = data,
  parl_rows = 11,
  party_seats = data$seats,
  type = "semicircle"
)
german_data <- german_data %>% mutate(overhang_seats = rep(overhangseats, number_overhangseats))
german_parliament <- ggplot(german_data, aes(x,
  y,
  colour = party_short
)) +
  geom_parliament_seats(size = 2) +
  # Hollow the overhang seats as follows:
  geom_overhang_seats(overhang_seats == 1) +
  labs(
    colour = NULL,
    subtitle = "Overhang seats are hollow."
  ) +
  theme_void() +
  geom_parliament_bar(colour, party_short) + 
  theme(
    plot.title = element_text(hjust = 0.5),
    plot.subtitle = element_text(hjust = 0.5),
    legend.position = "none"
  ) +
  draw_partylabels(type = "semicircle",
                   party_colours = colour,
                   party_names = party_short,
                   party_seats = seats) +
  scale_colour_manual(
    values = german_data$colour,
    limits = german_data$party_short
  )
german_parliament
```


# Case Studies

I turn to additional examples where `ggparliament` may be a useful descriptive tool for political scientists. In one case study, I replicate an existing diagram of a legislature using `ggparliament`. In the other, I show how a `ggparliament` plot adds to the written description of the data.

## The 115th Congress and Questions of Party Unity in a Polarized Era [@lee2018115th]

Lee argues that despite the Republican majority in Congress and near-uniform party unity, the Republican party in the 115th Congress has been less effective at passing its legislative agenda because of internal party politics [-@lee2018115th]. Given that parties often do not call a vote until a majority is ensured, roll-call data may overstate party cohesion. 

A parliament plot showing Republican party cohesion in the 115th Congress looks like the following.

```{r, fig.width = 4, fig.height = 2.5, fig.pos="h", fig.cap="Party cohesion in the 115th Congress"}
us_congress <- election_data %>% 
  filter(country == "USA" &
           year == "2016" & 
           house == "Representatives") %>% 
  parliament_data(election_data = ., 
                  parl_rows = 8,
                  party_seats = .$seats,
                  type = 'semicircle') %>% 
  mutate(party_cohesion = rep(c(1,0), c(222, 213)))

ggplot(us_congress, aes(x, y, colour = party_long)) + 
  geom_parliament_seats(size = 2) + 
  geom_highlight_government(party_cohesion == 1, colour = "grey", size = 2.7) + 
  draw_majoritythreshold(n = 218, type = 'semicircle', linecolour = 'black', linetype = 1, linesize = 0.5, label = FALSE) +
  annotate("text", x = - 1.5, y = 2, label = "Mean party \ncohesion: 92%", size = 3) + 
  scale_color_manual(values = us_congress$colour,
                     limits = us_congress$party_long) +
  theme_ggparliament() + 
  theme(legend.position = 'bottom') + 
  labs(color = NULL)
```


## Where You Sit is Where You Stand: The Impact of Seating Proximity on Legislative Cue-Taking [@masket2008you]

Masket shows that deskmate pairs in the California legislative assembly vote identically even if they are not ideologically similar [-@masket2008you]. This suggests that vote cue-taking, to some extent, is influenced by the location of fellow legislators. The author provides a diagram which depicts the 1949 California assembly. As evidenced in the figures below, seating was not always partisan. I replicate Masket's figure in `ggparliament` immediately below.

```{r, fig.width = 7, fig.height = 3, fig.pos="h", fig.cap="Figure 1 in Masket (2008)"}
img <- readPNG("masket_screenshot.png")
img <- grid.raster(img)
```

```{r, fig.width = 7, fig.height = 4, fig.pos="h", fig.cap="Replication of Figure 1 in Masket (2008)"}
# create dummy data frame for expanding to individual seats
CA <- data.frame(
  legislator = c("FALSE", "TRUE", "FALSE","TRUE"),
  seats = c(2, 8, 2, 72)
)

# load names and parties
masket_rep <- read.csv("masket_replication.csv", stringsAsFactors = FALSE)
# add row for speaker
speaker_row <- data.frame(legislator = "Speaker", seats = "1", 
                          y = 5.8, x = 7.2,  representative = "Speaker", party = "D")
CA <- CA %>% 
  parliament_data(election_data = .,
                  parl_rows = 13, 
                  party_seats = .$seats,
                  type = 'classroom') %>% 
  bind_cols(masket_rep) %>% 
  mutate(y = ifelse(row_number() %% 2 == 0, y-0.70, y)) %>% 
  mutate(y = ifelse(row_number() %% 2 == 1, y-0.6, y)) %>% 
  mutate(x = x - 0.5) 
CA <- rbind(CA, speaker_row)


rep <- ggplot(data= CA, aes(x = y , y = x, fill = party)) +
  geom_label(aes(x= y, y = x, label = representative), size = 2.3)+
  scale_fill_manual(values = c("white", "gray"),
                     limits = c("D", "R")) +
  theme_ggparliament() + 
  theme(legend.position = 'none') 
comb <- cowplot::plot_grid(img, rep, ncol = 1)
comb
#ggsave(comb, file = "CA-gov-rep.png", width = 6, height = 3)
```






# Conclusion

Blah blah
Future direction, etc.



# References

<div id="refs"></div>

# Appendix

## `R` package

See https://CRAN.R-project.org/package=ggparliament. 

## Paper GitHub repo

https://github.com/zmeers/ggparliament_paper
